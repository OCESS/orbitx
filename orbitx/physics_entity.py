import numpy as np

from . import orbitx_pb2 as protos


class PhysicsEntity:
    habitat_hull_strength = 50
    spacestation_hull_strength = 100

    def __init__(self, entity: protos.Entity):
        assert isinstance(entity, protos.Entity)
        self.proto = entity

    def __repr__(self):
        return self.proto.__repr__()

    def __str__(self):
        return self.proto.__str__()

    @property
    def pos(self):
        return np.asarray([self.proto.x, self.proto.y])

    @pos.setter
    def pos(self, x):
        self.proto.x = x[0]
        self.proto.y = x[1]

    @property
    def v(self):
        return np.asarray([self.proto.vx, self.proto.vy])

    @v.setter
    def v(self, x):
        self.proto.vx = x[0]
        self.proto.vy = x[1]


for field in protos.Entity.DESCRIPTOR.fields:
    # For every field in the underlying protobuf entity, make a
    # convenient equivalent property to allow code like the following:
    # PhysicsEntity(entity).heading = 5
    setattr(PhysicsEntity, field.name, property(
        fget=lambda self, name=field.name: getattr(self.proto, name),
        fset=lambda self, val, name=field.name: setattr(self.proto, name, val),
        fdel=lambda self, name=field.name: delattr(self.proto, name),
        doc=f"Proxy of the underlying field, self.proto.{field.name}"))

# A note about functions with the signature "(self, *, arg1=None, arg2=None"
# there are a lot of float parameters to the upcoming APIs, so I think it's
# best for the callsite to have to specify what argument is what. For example,
# habitat.fuel_cons(throttle=0.2)
# as opposed to
# habitat.fuel_cons(0.2)
# The former is hopefully much clearer, so I think mandatory keyword arguments
# is better in this case.


class Engine(object):
    def __init__(self, *, max_fuel_cons=None, max_acc=None):
        """
        max_fuel_cons: kg/s consumption of fuel at max throttle
        max_acc: m/s/s acceleration from engine at max throttle
        """
        assert max_fuel_cons is not None
        assert max_acc is not None
        self._max_fuel_cons = max_fuel_cons
        self._max_acc = max_acc  # max acceleration

    def fuel_cons(self, *, throttle=None):
        assert throttle is not None
        return abs(throttle) * self._max_fuel_cons

    def acceleration(self, *, throttle=None):
        """
        throttle: unitless float, nominally in the range [0, 1]
        fuel: kg of fuel available for engine to burn
        returns the amount of linear acceleration generated by the engine.
        """
        assert throttle is not None
        return throttle * self._max_acc


class ReactionWheel(object):
    def __init__(self, *, max_spin_change=None):
        """
        max_spin_change: radians/s/s, maximum angular acceleration
        """
        assert max_spin_change is not None
        self._max_spin_change = max_spin_change

    def spin_change(self, *, requested_spin_change=None):
        """
        requested_spin_change: radians/s/s
        returns the requested spin change, bounded by max_spin_change
        """
        assert requested_spin_change is not None
        if requested_spin_change < -self._max_spin_change:
            return -self._max_spin_change
        elif requested_spin_change > self._max_spin_change:
            return self._max_spin_change
        else:
            return requested_spin_change


class Habitat():
    """Static class implementing hab engine and reaction wheel constraints."""
    engine = Engine(max_fuel_cons=1, max_acc=12)
    rw = ReactionWheel(max_spin_change=1)

    @classmethod
    def spin_change(cls, *, requested_spin_change=None):
        assert requested_spin_change is not None
        return cls.rw.spin_change(
            requested_spin_change=requested_spin_change)

    @classmethod
    def fuel_cons(cls, *, throttle=None):
        assert throttle is not None
        return abs(cls.engine.fuel_cons(throttle=throttle))

    @classmethod
    def acceleration(cls, *, throttle=None, heading=None):
        assert throttle is not None
        assert heading is not None
        acc = cls.engine.acceleration(throttle=throttle)
        return np.cos(heading) * acc, np.sin(heading) * acc
