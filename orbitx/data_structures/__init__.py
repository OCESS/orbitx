"""Classes that represent the state of the entire system and entities within.

These classes wrap protobufs, which are basically a fancy NamedTuple that is
generated by the generate-protobuf script. You can read more about protobufs
online, but mainly they're helpful for serializing data over the network
and keeping data organized.

---

If you found this file while searching around the codebase, you might be
looking to add a new piece of data to the OrbitX simulation. Here's a rough
guide to help you decide where to put a new piece of data.

*Importantly!* You can pick any of these three approaches for where to store
your data, and it should not matter for any code outside of data_structures.py!
As long as you expose the data with a member function in one of the classes in
this file, it shouldn't matter how it's implemented. Wow. Love object-oriented
programming and abstractions!

1. Are you adding a piece of data that will not change during the runtime of
   the program? If the piece of data is a constant, then it's probably best
   to hardcode the piece of data in a standalone constants-only file, or
   create a new one if that would be a cleaner way of organizing source files.
   Examples:
   - The gravitational constant, G, is already hardcoded in a python file.
   - The names of planets and engineering components are hardcoded in strings.py
   - More constants about components are hardcoded in electroconstants.py

   Sample implementation (hardcoding the names of Radiators):
   - If there are 8 radiators, make an 8-long list in strings.py of each name
   - In data_structures.py, define an accessor for the name of a radiator as
       `def name(self): return strings.RADIATOR_NAMES[self._radiator_index]`

2. Are you adding a piece of data that will change continuously during simulation,
   and will need to be stored in a savefile to properly reload the simulation?
   If so, add a definition to orbitx.proto so that your data will be represented
   in the savefile (which is just a JSON representation of the protobuf). Also,
   Add the piece of data to the y-vector array representation of simulation data
   so that ode_solver can have access to it. Look for #Y_VECTOR_CHANGESITE to
   see where to change the y-vector.
   Examples:
   - x, y, and velocities
   - fuel amounts and SRB burntime

   Sample implementation (adding a 'sauce_amount' field to Components):
   - In orbitx.proto add `double sauce_amount = [the next free field index number];`
     to `message Component`
   - Copy and run the `python -m grpc_tools.protoc` line in your terminal,
     which will update the autogenerated `orbitx_pb2.Component` class and all its
     code to have the `sauce_amount` field. The `if populate_array` in EngineeringState
     will then automatigaclly put the sauce_amount field in the right data array.
   - Add an accessor to the ComponentView and ComponentList definitions in
     data_structures.py, similar to other fields.

3. Are you adding a piece of data that can be calculated from other existing
   pieces of data? If so, don't store the data anywhere, just define a helper
   function or accessor that will calculate it for you on-demand!
   Examples:
   - The acceleration acting on an entity is calculated from mainly gravitation,
     with some entities being affected by engines and drag. It's not stored
     anywhere, but it _is_ calculated ~hundreds of times per second in
     ode_solver.py
   - The resistance across an engineering component can be calculated from its
     current temperature and its starting resistance.

   If this piece of data is being calculated hundreds of times per second, i.e.
   is used by ode_solver.py, then optimization _may_ be required. This is
   something that's fiddly and requires empirical runtime data once you've
   implemented something, so don't worry about it for now. "Premature optimization
   is the root of all evil." Reach out to Patrick if the program's performance
   degrades, especially at low- or mid-speeds of time acceleration.

   Simple sample implenetation (Component resistance):
   - Add the following member accessor to components:
       ```
       def resistance(self):
           # From Wikipedia article on 'Temperature coefficient'
           return self._base_resistance() * (1 + common.ALPHA_RESIST_GAIN * self.temperature)
       ```
"""

import numpy as np

DTYPE = np.float64  # Datatype used by orbitx internally.
